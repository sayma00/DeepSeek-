{
  "from django.docx": "from django.shortcuts import render\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.http import JsonResponse\nfrom django.core.files.storage import default_storage\nfrom django.conf import settings\nimport requests\nimport os\nimport json\nimport uuid\nimport PyPDF2\nimport docx\nimport pytesseract\nfrom PIL import Image, ImageEnhance, ImageFilter\n# ===============================\n# SET TESSERACT PATH HERE\n# ===============================\n# For Windows - change the path if installed elsewhere\npytesseract.pytesseract.tesseract_cmd = r\"C:\\Program Files\\Tesseract-OCR\\tesseract.exe\"\ndef chat_ui(request):\n    return render(request, 'chatbox/index.html')\ndef preprocess_image(image_path):\n    \"\"\"Enhance image quality for better OCR accuracy.\"\"\"\n    img = Image.open(image_path)\n    img = img.convert('L')  # Convert to grayscale\n    img = img.filter(ImageFilter.SHARPEN)  # Sharpen text\n    return img\ndef _extract_text_from_file(file_path, chunk_size=3000):\n    \"\"\"\n    Extracts text from txt, pdf, docx, and image files.\n    Splits large files into chunks for easier handling.\n    \"\"\"\n    ext = os.path.splitext(file_path)[1].lower()\n    full_text = \"\"\n    try:\n        if ext == \".txt\":\n            with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                full_text = f.read()\n        elif ext == \".pdf\":\n            with open(file_path, \"rb\") as f:\n                reader = PyPDF2.PdfReader(f)\n                pages = []\n                for p in reader.pages:\n                    try:\n                        text = p.extract_text()\n                        if text:\n                            pages.append(text)\n                        else:\n                            pages.append(\"\")\n                    except Exception:\n                        pages.append(\"\")\n                full_text = \"\\n\".join(pages)\n        elif ext == \".docx\":\n            doc = docx.Document(file_path)\n            full_text = \"\\n\".join(p.text for p in doc.paragraphs if p.text.strip())\n        elif ext in [\".png\", \".jpg\", \".jpeg\", \".bmp\", \".tiff\"]:\n            img = preprocess_image(file_path)\n            full_text = pytesseract.image_to_string(img, lang=\"eng\")\n    except Exception as e:\n        return f\"[ERROR_EXTRACTING_FILE: {str(e)}]\"\n    # CHUNKING\n    chunks = []\n    text_len = len(full_text)\n    for i in range(0, text_len, chunk_size):\n        chunks.append(full_text[i:i + chunk_size])\n    return \"\\n---CHUNK_BREAK---\\n\".join(chunks)\ndef _user_requested_export(message_text):\n    \"\"\"Check if user explicitly asked for a downloadable file.\"\"\"\n    if not message_text:\n        return False\n    m = message_text.lower()\n    keywords = [\n        \"download\", \"export\", \"json\", \"excel\", \"xlsx\",\n        \"csv\", \"file\", \"download json\", \"download excel\", \"save as\"\n    ]\n    return any(k in m for k in keywords)\n@csrf_exempt\ndef send_to_ollama(request):\n    if request.method != \"POST\":\n        return JsonResponse({\"error\": \"Invalid request method.\"}, status=405)\n    u\n---CHUNK_BREAK---\nser_msg = request.POST.get(\"message\", \"\").strip()\n    uploaded_files = request.FILES.getlist(\"files\")\n    extracted_per_file = {}\n    extraction_errors = []\n    # Extract text from files\n    for uploaded_file in uploaded_files:\n        saved = default_storage.save(uploaded_file.name, uploaded_file)\n        abs_path = default_storage.path(saved)\n        text = _extract_text_from_file(abs_path)\n        extracted_per_file[uploaded_file.name] = text\n        try:\n            os.remove(abs_path)\n        except Exception:\n            pass\n    wants_export = _user_requested_export(user_msg)\n    json_url = None\n    json_filename = None\n    # Create JSON if requested\n    if wants_export and extracted_per_file:\n        json_filename = f\"extracted_{uuid.uuid4().hex}.json\"\n        os.makedirs(settings.MEDIA_ROOT, exist_ok=True)\n        json_path = os.path.join(settings.MEDIA_ROOT, json_filename)\n        with open(json_path, \"w\", encoding=\"utf-8\") as jf:\n            json.dump(extracted_per_file, jf, ensure_ascii=False, indent=2)\n        json_url = f\"/media/{json_filename}\"\n    # Build prompt for the model\n    if not uploaded_files:\n        prompt = user_msg or \"Hello\"\n    else:\n        prompt = \"You are an assistant. The user uploaded file(s) whose extracted text is below.\\n\\n\"\n        for fname, txt in extracted_per_file.items():\n            prompt += f\"---FILE_START---\\nFilename: {fname}\\nContent:\\n{txt}\\n---FILE_END---\\n\\n\"\n        prompt += \"User's question or instruction:\\n\" + (user_msg or \"Please summarize the files.\")\n    payload = {\n        \"model\": \"deepseek-r1:7b\",\n        \"prompt\": prompt,\n        \"stream\": False\n    }\n    try:\n        resp = requests.post(\"http://localhost:11434/api/generate\", json=payload, timeout=1800)\n        resp.encoding = 'utf-8'\n        model_out = resp.json().get(\"response\", \"\")\n    except Exception as e:\n        model_out = f\"[ERROR_CALLING_MODEL: {str(e)}]\"\n    return JsonResponse({\n        \"response\": model_out,\n        \"json_url\": json_url,\n        \"json_filename\": json_filename,\n        \"errors\": extraction_errors if extraction_errors else None\n    })"
}